local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- ä½¿ç”¨ Rayfield å†…ç½®å¯†é’¥ç³»ç»Ÿ
local Window = Rayfield:CreateWindow({
    Name = "å¤å¤å¤§å¸è„šæœ¬ - " .. (identifyexecutor and identifyexecutor() or "æœªçŸ¥æ‰§è¡Œå™¨"),
    LoadingTitle = "å¤å¤å¤§å¸è„šæœ¬åŠ è½½ä¸­",
    LoadingSubtitle = "å°Šäº«ç‰¹æƒç‰ˆ",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "StitchConfig",
        FileName = "Settings"
    },
    Discord = {
        Enabled = false,
        Invite = "https://discord.gg/",
        RememberJoins = true
    },
    KeySystem = true, -- å¯ç”¨å†…ç½®å¯†é’¥ç³»ç»Ÿ
    KeySettings = {
        Title = "å¤å¤å¤§å¸è„šæœ¬éªŒè¯",
        Subtitle = "è¯·è¾“å…¥æœ‰æ•ˆå¯†é’¥",
        Note = "æ²¡æœ‰å¯†é’¥ï¼ŸåŠ å…¥Discordè·å–",
        FileName = "StitchKey",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"2025", "666", "KUNKUN666", "666free", "TAIYOUYISILE"} -- æœ‰æ•ˆå¯†é’¥åˆ—è¡¨
    }
})

-- å¤å¤å¤§å¸è„šæœ¬å¼¹æ€§åŠ¨ç”»
local function CreateKunKunAnimation()
    -- åˆ›å»ºå…¨å±èƒŒæ™¯
    local bg = Drawing.new("Square")
    bg.Size = workspace.CurrentCamera.ViewportSize
    bg.Position = Vector2.new(0, 0)
    bg.Color = Color3.new(0, 0, 0)
    bg.Filled = true
    bg.Transparency = 1
    bg.Visible = true
    bg.ZIndex = 999
    
    -- åˆ›å»ºå¤å¤å¤§å¸æ–‡å­—
    local text = Drawing.new("Text")
    text.Text = "å¤å¤å¤§å¸è„šæœ¬"
    text.Size = 100
    text.Center = true
    text.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2, -200)
    text.Color = Color3.new(1, 0.2, 0.2)
    text.Outline = true
    text.OutlineColor = Color3.new(1, 1, 1)
    text.Transparency = 0
    text.Visible = true
    text.ZIndex = 1000
    
    -- åˆ›å»ºå‰¯æ ‡é¢˜
    local subText = Drawing.new("Text")
    subText.Text = "å°Šäº«ç‰¹æƒç‰ˆ - å¯åŠ¨æˆåŠŸ"
    subText.Size = 40
    subText.Center = true
    subText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2, -100)
    subText.Color = Color3.new(0.8, 0.8, 1)
    subText.Outline = true
    subText.OutlineColor = Color3.new(0.2, 0.2, 0.2)
    subText.Transparency = 0
    subText.Visible = true
    subText.ZIndex = 1000
    
    -- å¼¹æ€§åŠ¨ç”»å‡½æ•°
    local function elasticAnimation(obj, targetY, duration)
        local startY = obj.Position.Y
        local startTime = tick()
        local damping = 0.7
        local stiffness = 0.3
        
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            local elapsed = tick() - startTime
            local progress = elapsed / duration
            
            if progress >= 1 then
                obj.Position = Vector2.new(obj.Position.X, targetY)
                connection:Disconnect()
                return
            end
            
            local overshoot = math.sin(progress * math.pi * 4) * (1 - progress)
            local newY = targetY + (startY - targetY) * math.pow(1 - progress, 2) * overshoot * stiffness
            stiffness = stiffness * damping
            obj.Position = Vector2.new(obj.Position.X, newY)
        end)
    end
    
    spawn(function()
        for i = 0, 1, 0.05 do
            bg.Transparency = 1 - i * 0.7
            wait(0.01)
        end
        
        elasticAnimation(text, workspace.CurrentCamera.ViewportSize.Y/2 - 100, 1.5)
        
        wait(0.2)
        elasticAnimation(subText, workspace.CurrentCamera.ViewportSize.Y/2 + 20, 1.3)
        
        wait(3.5)
        
        for i = 0, 1, 0.05 do
            text.Transparency = i
            subText.Transparency = i
            bg.Transparency = 0.3 + i * 0.7
            wait(0.01)
        end
        
        bg:Remove()
        text:Remove()
        subText:Remove()
    end)
end

-- å¤åˆ¶åˆ°å‰ªè´´æ¿å‡½æ•°
local function CopyToClipboard(text)
    if setclipboard then
        setclipboard(text)
        return true
    elseif writeclipboard then
        writeclipboard(text)
        return true
    elseif toclipboard then
        toclipboard(text)
        return true
    else
        print("[å¤åˆ¶å†…å®¹] " .. text)
        return false
    end
end

-- æ˜¾ç¤ºå¤åˆ¶æˆåŠŸé€šçŸ¥
local function ShowCopyNotification(success, content)
    if success then
        Rayfield:Notify({
            Title = "å¤åˆ¶æˆåŠŸ",
            Content = "å·²å¤åˆ¶åˆ°å‰ªè´´æ¿: " .. content,
            Duration = 3,
            Image = 4483362458
        })
    else
        Rayfield:Notify({
            Title = "å¤åˆ¶å¤±è´¥",
            Content = "è¯·æ‰‹åŠ¨å¤åˆ¶æ§åˆ¶å°ä¸­çš„å†…å®¹",
            Duration = 5,
            Image = 4483362458
        })
    end
end

-- å­å¼¹ç©¿å¢™åŠŸèƒ½
local bulletPenetration = false
local penetrationPower = 3 -- å¯ç©¿é€çš„å¢™ä½“æ•°é‡

local function hasPenetrationAbility()
    return bulletPenetration
end

-- ä¿®æ”¹å¢™ä½“æ£€æµ‹å‡½æ•°ä»¥æ”¯æŒç©¿å¢™
local function isVisible(pos, targetCharacter)
    if not wallCheckEnabled then return true end
    
    local origin = Camera.CFrame.Position
    local direction = (pos - origin).Unit
    local ray = Ray.new(origin, direction * (origin - pos).Magnitude)
    
    local ignoreList = {LocalPlayer.Character, Camera}
    if targetCharacter then
        table.insert(ignoreList, targetCharacter)
    end
    
    local part, position = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    
    -- å¦‚æœå¼€å¯ç©¿å¢™åŠŸèƒ½ï¼Œåˆ™å¿½ç•¥å¢™ä½“æ£€æµ‹
    if bulletPenetration and hasPenetrationAbility() then
        return true
    end
    
    return part == nil
end

-- åˆ†ç¦»å¼ç©å®¶ ESP ç³»ç»Ÿ
local espEnabled = false
local espBoxEnabled = true
local espNameEnabled = true
local espDistanceEnabled = true
local espHealthEnabled = true
local espHealthBarEnabled = true
local espTracerEnabled = true
local espCache = {}

local function createESPObject(plr)
    local esp = {
        Box = Drawing.new("Quad"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBar = Drawing.new("Quad"),
        HealthText = Drawing.new("Text"),
        Tracer = Drawing.new("Line")
    }
    
    -- åˆå§‹åŒ–å„ä¸ªESPç»„ä»¶
    esp.Box.Thickness = 1.5
    esp.Box.Filled = false
    esp.Box.ZIndex = 5
    esp.Box.Visible = espBoxEnabled and espEnabled
    
    esp.Name.Size = 18
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.ZIndex = 6
    esp.Name.Visible = espNameEnabled and espEnabled
    
    esp.Distance.Size = 16
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.ZIndex = 6
    esp.Distance.Visible = espDistanceEnabled and espEnabled
    
    esp.HealthBar.Filled = true
    esp.HealthBar.Thickness = 1
    esp.HealthBar.ZIndex = 5
    esp.HealthBar.Visible = espHealthBarEnabled and espEnabled
    
    esp.HealthText.Size = 14
    esp.HealthText.Center = true
    esp.HealthText.Outline = true
    esp.HealthText.ZIndex = 6
    esp.HealthText.Visible = espHealthEnabled and espEnabled
    
    esp.Tracer.Thickness = 1.5
    esp.Tracer.ZIndex = 4
    esp.Tracer.Visible = espTracerEnabled and espEnabled
    
    espCache[plr] = esp
    return esp
end

local function getTeamColor(plr)
    if plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team then
        return Color3.fromRGB(0, 255, 0)
    else
        return Color3.fromRGB(255, 0, 0)
    end
end

local function isTeammate(plr)
    if plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team then
        return true
    end
    return false
end

local function updateESP()
    if not espEnabled then 
        for _, esp in pairs(espCache) do
            for _, obj in pairs(esp) do
                obj.Visible = false
            end
        end
        return 
    end
    
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LocalPlayer then continue end
        
        if espShowEnemyOnly and isTeammate(plr) then
            if espCache[plr] then
                for _, obj in pairs(espCache[plr]) do
                    obj.Visible = false
                end
            end
            continue
        end
        
        local char = plr.Character
        if not char then
            if espCache[plr] then
                for _, obj in pairs(espCache[plr]) do
                    obj.Visible = false
                end
            end
            continue 
        end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        local head = char:FindFirstChild("Head")
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        
        if not (root and head and humanoid) then continue end
        
        local rootPos, rootVis = Camera:WorldToViewportPoint(root.Position)
        local headPos, headVis = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
        
        if not (rootVis and headVis) then
            if espCache[plr] then
                for _, obj in pairs(espCache[plr]) do
                    obj.Visible = false
                end
            end
            continue
        end
        
        local esp = espCache[plr] or createESPObject(plr)
        
        local height = math.abs(headPos.Y - rootPos.Y) * 1.5
        local width = height * 0.6
        local left = headPos.X - width / 2
        local right = headPos.X + width / 2
        
        local color = getTeamColor(plr)
        
        -- æ›´æ–°æ–¹æ¡†
        esp.Box.Visible = espBoxEnabled
        esp.Box.Color = color
        esp.Box.PointA = Vector2.new(left, headPos.Y)
        esp.Box.PointB = Vector2.new(right, headPos.Y)
        esp.Box.PointC = Vector2.new(right, headPos.Y + height)
        esp.Box.PointD = Vector2.new(left, headPos.Y + height)
        
        -- æ›´æ–°åå­—
        esp.Name.Visible = espNameEnabled
        esp.Name.Color = color
        esp.Name.Position = Vector2.new(headPos.X, headPos.Y - 20)
        esp.Name.Text = plr.Name
        
        -- æ›´æ–°è·ç¦»
        local distance = math.floor((root.Position - Camera.CFrame.Position).Magnitude)
        esp.Distance.Visible = espDistanceEnabled
        esp.Distance.Color = color
        esp.Distance.Position = Vector2.new(headPos.X, headPos.Y + height + 5)
        esp.Distance.Text = tostring(distance) .. "m"
        
        -- æ›´æ–°è¡€æ¡å’Œè¡€é‡
        local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local barWidth = width
        local barHeight = 5
        local barX = left
        local barY = headPos.Y + height + 20
        
        esp.HealthBar.Visible = espHealthBarEnabled
        esp.HealthBar.Color = Color3.new(1 - healthPercent, healthPercent, 0)
        esp.HealthBar.PointA = Vector2.new(barX, barY)
        esp.HealthBar.PointB = Vector2.new(barX + barWidth * healthPercent, barY)
        esp.HealthBar.PointC = Vector2.new(barX + barWidth * healthPercent, barY + barHeight)
        esp.HealthBar.PointD = Vector2.new(barX, barY + barHeight)
        
        esp.HealthText.Visible = espHealthEnabled
        esp.HealthText.Color = Color3.new(1, 1, 1)
        esp.HealthText.Position = Vector2.new(barX + barWidth / 2, barY - 10)
        esp.HealthText.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
        
        -- æ›´æ–°è¿½è¸ªçº¿
        esp.Tracer.Visible = espTracerEnabled
        esp.Tracer.Color = color
        
        local startPoint
        if tracerPosition == "Top" then
            startPoint = Vector2.new(Camera.ViewportSize.X/2, 0)
        else
            startPoint = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
        end
        
        local endPoint = Vector2.new(headPos.X, headPos.Y + height/2)
        
        esp.Tracer.From = startPoint
        esp.Tracer.To = endPoint
    end
    
    for plr, esp in pairs(espCache) do
        if not plr or not plr.Parent or plr == LocalPlayer then
            for _, obj in pairs(esp) do
                obj.Visible = false
                obj:Remove()
            end
            espCache[plr] = nil
        end
    end
end

-- ä¼˜åŒ– NPC é€è§†æµç•…åº¦
local npcEspEnabled = false
local npcEspCache = {}
local npcEspUpdateRate = 0.1 -- æ›´æ–°é¢‘ç‡ï¼ˆç§’ï¼‰
local lastNpcEspUpdate = 0

local function createNpcESPObject(model)
    local esp = {
        Box = Drawing.new("Quad"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }
    
    esp.Box.Thickness = 1.5
    esp.Box.Filled = false
    esp.Box.Color = Color3.fromRGB(255, 165, 0)
    esp.Box.ZIndex = 4
    esp.Box.Visible = npcEspEnabled
    
    esp.Name.Size = 16
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.Color = Color3.fromRGB(255, 165, 0)
    esp.Name.ZIndex = 4
    esp.Name.Visible = npcEspEnabled
    
    esp.Distance.Size = 14
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.Color = Color3.fromRGB(255, 165, 0)
    esp.Distance.ZIndex = 4
    esp.Distance.Visible = npcEspEnabled
    
    npcEspCache[model] = esp
    return esp
end

local function updateNpcESP()
    if not npcEspEnabled then return end
    
    local currentTime = tick()
    if currentTime - lastNpcEspUpdate < npcEspUpdateRate then
        return
    end
    lastNpcEspUpdate = currentTime
    
    for _, model in ipairs(workspace:GetDescendants()) do
        if model:IsA("Model") and model:FindFirstChildOfClass("Humanoid") and not Players:GetPlayerFromCharacter(model) then
            local root = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso")
            local head = model:FindFirstChild("Head")
            
            if not (root and head) then
                if npcEspCache[model] then
                    for _, obj in pairs(npcEspCache[model]) do
                        obj.Visible = false
                    end
                end
                continue
            end
            
            local rootPos, rootVis = Camera:WorldToViewportPoint(root.Position)
            local headPos, headVis = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
            
            if not (rootVis and headVis) then
                if npcEspCache[model] then
                    for _, obj in pairs(npcEspCache[model]) do
                        obj.Visible = false
                    end
                end
                continue
            end
            
            local esp = npcEspCache[model] or createNpcESPObject(model)
            
            local height = math.abs(headPos.Y - rootPos.Y) * 1.5
            local width = height * 0.6
            local left = headPos.X - width / 2
            local right = headPos.X + width / 2
            
            esp.Box.Visible = npcEspEnabled
            esp.Box.PointA = Vector2.new(left, headPos.Y)
            esp.Box.PointB = Vector2.new(right, headPos.Y)
            esp.Box.PointC = Vector2.new(right, headPos.Y + height)
            esp.Box.PointD = Vector2.new(left, headPos.Y + height)
            
            esp.Name.Visible = npcEspEnabled
            esp.Name.Position = Vector2.new(headPos.X, headPos.Y - 15)
            esp.Name.Text = model.Name
            
            local distance = math.floor((root.Position - Camera.CFrame.Position).Magnitude)
            esp.Distance.Visible = npcEspEnabled
            esp.Distance.Position = Vector2.new(headPos.X, headPos.Y + height + 5)
            esp.Distance.Text = tostring(distance) .. "m"
        end
    end
    
    for model, esp in pairs(npcEspCache) do
        if not model or not model.Parent then
            for _, obj in pairs(esp) do
                obj.Visible = false
                obj:Remove()
            end
            npcEspCache[model] = nil
        end
    end
end

-- åˆ›å»ºä¸»çª—å£å†…å®¹
local function CreateMainWindowContent()
    -- å…¬å‘Š Tab
    local Tab1 = Window:CreateTab("å…¬å‘Š", 7733779610)
    
    local function getDate() return os.date("%Y-%m-%d %H:%M") end
    local function getPlayer()
        local p = game.Players.LocalPlayer
        return {
            ["ç”¨æˆ·å"]   = p.Name,
            ["æ˜¾ç¤ºå"]   = p.DisplayName,
            ["ç”¨æˆ·ID"]   = p.UserId,
            ["æ³¨å†Œå¤©æ•°"] = p.AccountAge,
            ["å½“å‰æ¸¸æˆ"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
        }
    end
    
    Tab1:CreateSection("ç³»ç»Ÿä¿¡æ¯")
    Tab1:CreateLabel("ğŸ“… å½“å‰æ—¶é—´: " .. getDate())
    
    for k, v in pairs(getPlayer()) do
        Tab1:CreateLabel(k .. "ï¼š " .. tostring(v))
    end
    
    Tab1:CreateButton({
        Name = "ä¸€é”®å¤åˆ¶QQå·", 
        Callback = function() 
            local success = CopyToClipboard("913348285")
            ShowCopyNotification(success, "913348285")
        end
    })
    
    -- äººç‰©åŠŸèƒ½ Tab
    local Tab2 = Window:CreateTab("äººç‰©åŠŸèƒ½", 7733779610)
    
    -- å…¼å®¹ executor æ²¡æœ‰ mouse1press / mouse1release
    local mouse1press  = mouse1press  or function()
        local vim = game:GetService("VirtualInputManager")
        vim:SendMouseButtonEvent(0,0,0,true,game,1)
    end
    local mouse1release = mouse1release or function()
        local vim = game:GetService("VirtualInputManager")
        vim:SendMouseButtonEvent(0,0,0,false,game,1)
    end
    
    -- AI-Aimbot ç‹¬ç«‹æ ‡ç­¾é¡µ
    local Tab3 = Window:CreateTab("AI-Aimbot", 7733961748)
    
    -- é€šç”¨å‚æ•°
    local aimbotEnabled      = false
    local aimbotSmooth       = 0.35
    local aimbotBone         = "Head"
    local aimbotPrediction   = 0.12
    local aimbotDelay        = 0.08
    local aimbotCheckTeam    = false
    local aimbotConn
    local aimbotMode = "Distance"
    local wallCheckEnabled = false
    local aimLineEnabled = false
    local aimLine = Drawing.new("Line")
    
    -- åˆå§‹åŒ–è‡ªç„çº¿æ¡
    aimLine.Visible = false
    aimLine.Thickness = 1.5
    aimLine.Color = Color3.fromRGB(0, 255, 0)
    aimLine.ZIndex = 11
    
    -- ç¼ºå¤±å˜é‡ä¸€æ¬¡æ€§è¡¥å…¨
    local Camera = workspace.CurrentCamera
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    -- 1. è·Ÿéšé¼ æ ‡ FOV
    local mouseFOV      = 120
    local mouseFovCircle = Drawing.new("Circle")
    mouseFovCircle.NumSides  = 64
    mouseFovCircle.Radius    = mouseFOV
    mouseFovCircle.Thickness = 1.5
    mouseFovCircle.Color     = Color3.fromRGB(255,255,255)
    mouseFovCircle.Filled    = false
    mouseFovCircle.Visible   = false
    mouseFovCircle.ZIndex = 10
    
    -- 2. å›ºå®šä¸­å¿ƒ FOV
    local fixedFOV      = 90
    local fixedFovCircle = Drawing.new("Circle")
    fixedFovCircle.NumSides  = 64
    fixedFovCircle.Radius    = fixedFOV
    fixedFovCircle.Thickness = 1.5
    fixedFovCircle.Color     = Color3.fromRGB(255,165,0)
    fixedFovCircle.Filled    = false
    fixedFovCircle.Visible   = false
    fixedFovCircle.ZIndex = 9
    
    -- å›ºå®šåœ†ä¸­å¿ƒä¸€æ¬¡è®¾ç½®
    local function setFixedCenter()
        local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        fixedFovCircle.Position = center
        aimLine.From = center
    end
    Camera:GetPropertyChangedSignal("ViewportSize"):Connect(setFixedCenter)
    setFixedCenter()
    
    -- å·¥å…·å‡½æ•°
    local function getAimPos(character)
        if not character then return nil end
        local root = character:FindFirstChild("HumanoidRootPart")
        local bone = character:FindFirstChild(aimbotBone) or character:FindFirstChild("Head")
        if not (root and bone) then return nil end
        
        local vel = root.Velocity
        return bone.Position + vel * aimbotPrediction
    end
    
    local function inAnyFOV(worldPos)
        local screenPos = Camera:WorldToViewportPoint(worldPos)
        if screenPos.Z <= 0 then return false end
        
        local mousePos = UserInputService:GetMouseLocation()
        local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        
        if mouseFovCircle.Visible then
            if (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude <= mouseFOV then
                return true
            end
        end
        
        if fixedFovCircle.Visible then
            if (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude <= fixedFOV then
                return true
            end
        end
        
        return false
    end
    
    local function getClosest()
        local closest, minDist = nil, math.huge
        local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr == LocalPlayer then continue end
            if aimbotCheckTeam and plr.Team and plr.Team == LocalPlayer.Team then continue end
            
            local char = plr.Character
            if not char then continue end
            
            local aimPos = getAimPos(char)
            if not aimPos then continue end
            if not inAnyFOV(aimPos) then continue end
            
            local sp = Camera:WorldToViewportPoint(aimPos)
            if sp.Z <= 0 then continue end
            
            local ignoreList = {LocalPlayer.Character, Camera}
            if not isVisible(aimPos, char) then continue end
            
            local dist
            if aimbotMode == "Distance" then
                dist = (aimPos - Camera.CFrame.Position).Magnitude
            else
                dist = (Vector2.new(sp.X, sp.Y) - center).Magnitude
            end
            
            if dist < minDist then
                minDist, closest = dist, plr
            end
        end
        return closest
    end
    
    -- ä¸»å¾ªç¯ï¼ˆå·²ç§»é™¤è‡ªåŠ¨å¼€ç«ï¼‰
    local function startAimbot()
        if aimbotConn then return end
        
        aimbotConn = game:GetService("RunService").RenderStepped:Connect(function()
            if not aimbotEnabled then 
                aimLine.Visible = false
                return 
            end
            
            mouseFovCircle.Position = UserInputService:GetMouseLocation()

            local target = getClosest()
            if not target or not target.Character then 
                aimLine.Visible = false
                return 
            end
            
            local aimPos = getAimPos(target.Character)
            if not aimPos then 
                aimLine.Visible = false
                return 
            end

            if aimLineEnabled then
                local screenPos = Camera:WorldToViewportPoint(aimPos)
                if screenPos.Z > 0 then
                    aimLine.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                    aimLine.To = Vector2.new(screenPos.X, screenPos.Y)
                    aimLine.Visible = true
                else
                    aimLine.Visible = false
                end
            else
                aimLine.Visible = false
            end
            
            local delta = aimPos - Camera.CFrame.Position
            if delta.Magnitude < 0.01 then return end
            
            local targetCF = CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + delta)
            local currentLook = Camera.CFrame.LookVector
            local targetLook = targetCF.LookVector
            
            local dot = currentLook:Dot(targetLook)
            local angle = math.acos(math.clamp(dot, -1, 1))
            local maxAngle = math.rad(90)
            
            if angle <= maxAngle then
                local smoothFactor = math.clamp(aimbotSmooth, 0.01, 0.99)
                local newLook = currentLook:Lerp(targetLook, 1 - smoothFactor)
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + newLook)
            end
        end)
    end
    
    local function stopAimbot()
        if aimbotConn then 
            aimbotConn:Disconnect() 
            aimbotConn = nil 
        end
        mouseFovCircle.Visible = false
        fixedFovCircle.Visible = false
        aimLine.Visible = false
    end
    
    Tab3:CreateSection("AI-Aimbot")
    Tab3:CreateToggle({
        Name = "å¯ç”¨ Aimbot",
        CurrentValue = false,
        Callback = function(v)
            aimbotEnabled = v
            if v then 
                startAimbot() 
            else 
                stopAimbot() 
            end
        end
    })
    
    Tab3:CreateToggle({
        Name = "å­å¼¹ç©¿å¢™",
        CurrentValue = bulletPenetration,
        Callback = function(v) 
            bulletPenetration = v 
        end
    })
    
    Tab3:CreateToggle({
        Name = "ä»…ç„å‡†æ•Œäºº",
        CurrentValue = aimbotCheckTeam,
        Callback = function(v) aimbotCheckTeam = v end
    })
    
    Tab3:CreateToggle({
        Name = "å¢™ä½“æ£€æµ‹",
        CurrentValue = wallCheckEnabled,
        Callback = function(v) wallCheckEnabled = v end
    })
    
    Tab3:CreateToggle({
        Name = "æ˜¾ç¤ºè‡ªç„çº¿æ¡",
        CurrentValue = aimLineEnabled,
        Callback = function(v) aimLineEnabled = v end
    })
    
    Tab3:CreateDropdown({
        Name = "ç„å‡†æ–¹å¼",
        Options = {"Distance", "Crosshair"},
        CurrentOption = aimbotMode,
        Callback = function(v) aimbotMode = v end
    })
    
    Tab3:CreateSection("è·Ÿéšé¼ æ ‡ FOV")
    Tab3:CreateToggle({ 
        Name = "æ˜¾ç¤ºè·ŸéšFOV", 
        CurrentValue = false, 
        Callback = function(v) mouseFovCircle.Visible = v end 
    })
    
    Tab3:CreateSlider({
        Name = "åŠå¾„ï¼ˆæ»‘æ¡ï¼‰",
        Range = {0, 500},
        Increment = 5,
        Suffix = "px",
        CurrentValue = mouseFOV,
        Callback = function(v) 
            mouseFOV = v
            mouseFovCircle.Radius = v 
        end
    })
    
    Tab3:CreateSection("å›ºå®šä¸­å¿ƒ FOV")
    Tab3:CreateToggle({ 
        Name = "æ˜¾ç¤ºå›ºå®šFOV", 
        CurrentValue = false, 
        Callback = function(v) fixedFovCircle.Visible = v end 
    })
    
    Tab3:CreateSlider({
        Name = "åŠå¾„ï¼ˆæ»‘æ¡ï¼‰",
        Range = {0, 500},
        Increment = 5,
        Suffix = "px",
        CurrentValue = fixedFOV,
        Callback = function(v) 
            fixedFOV = v
            fixedFovCircle.Radius = v 
        end
    })
    
    Tab3:CreateSection("é€šç”¨å‚æ•°")
    Tab3:CreateSlider({
        Name = "å¹³æ»‘ç³»æ•°ï¼ˆæ»‘æ¡ï¼‰",
        Range = {0, 1},
        Increment = 0.01,
        Suffix = "",
        CurrentValue = aimbotSmooth,
        Callback = function(v) aimbotSmooth = v end
    })
    
    Tab3:CreateSlider({
        Name = "é¢„æµ‹ (ç§’)ï¼ˆæ»‘æ¡ï¼‰",
        Range = {0, 1},
        Increment = 0.01,
        Suffix = "s",
        CurrentValue = aimbotPrediction,
        Callback = function(v) aimbotPrediction = v end
    })
    
    Tab3:CreateDropdown({
        Name = "ç„å‡†éª¨éª¼",
        Options = {"Head","Neck","UpperTorso","HumanoidRootPart"},
        CurrentOption = aimbotBone,
        Callback = function(v) aimbotBone = v end
    })
    
    -- é€è§†åŠŸèƒ½ç‹¬ç«‹æ ‡ç­¾é¡µ
    local Tab4 = Window:CreateTab("é€è§†åŠŸèƒ½", 7733961749)
    
    Tab4:CreateSection("ç©å®¶é€è§†")
    Tab4:CreateToggle({
        Name = "å¯ç”¨ç©å®¶é€è§†", 
        CurrentValue = false, 
        Callback = function(v)
            espEnabled = v
            if v then
                if not espLoop then
                    espLoop = game:GetService("RunService").RenderStepped:Connect(updateESP)
                end
            else
                if espLoop then
                    espLoop:Disconnect()
                    espLoop = nil
                end
                for plr, esp in pairs(espCache) do
                    for _, obj in pairs(esp) do
                        pcall(function() obj:Remove() end)
                    end
                end
                table.clear(espCache)
            end
        end
    })

    Tab4:CreateToggle({
        Name = "æ˜¾ç¤ºæ–¹æ¡†",
        CurrentValue = espBoxEnabled,
        Callback = function(v) 
            espBoxEnabled = v 
            updateESP()
        end
    })

    Tab4:CreateToggle({
        Name = "æ˜¾ç¤ºåå­—",
        CurrentValue = espNameEnabled,
        Callback = function(v) 
            espNameEnabled = v 
            updateESP()
        end
    })

    Tab4:CreateToggle({
        Name = "æ˜¾ç¤ºè·ç¦»",
        CurrentValue = espDistanceEnabled,
        Callback = function(v) 
            espDistanceEnabled = v 
            updateESP()
        end
    })

    Tab4:CreateToggle({
        Name = "æ˜¾ç¤ºè¡€é‡",
        CurrentValue = espHealthEnabled,
        Callback = function(v) 
            espHealthEnabled = v 
            updateESP()
        end
    })

    Tab4:CreateToggle({
        Name = "æ˜¾ç¤ºè¡€æ¡",
        CurrentValue = espHealthBarEnabled,
        Callback = function(v) 
            espHealthBarEnabled = v 
            updateESP()
        end
    })

    Tab4:CreateToggle({
        Name = "æ˜¾ç¤ºè¿½è¸ªçº¿",
        CurrentValue = espTracerEnabled,
        Callback = function(v) 
            espTracerEnabled = v 
            updateESP()
        end
    })

    Tab4:CreateDropdown({
        Name = "çº¿æ¡ä½ç½®",
        Options = {"Top", "Bottom"},
        CurrentOption = tracerPosition,
        Callback = function(value)
            tracerPosition = value
            updateESP()
        end
    })

    Tab4:CreateToggle({
        Name = "åªæ˜¾ç¤ºæ•Œäºº",
        CurrentValue = espShowEnemyOnly,
        Callback = function(v)
            espShowEnemyOnly = v
            updateESP()
        end
    })
    
    Tab4:CreateSection("NPCé€è§†")
    Tab4:CreateToggle({
        Name = "å¢å¼ºNPCé€è§†", 
        CurrentValue = false, 
        Callback = function(v)
            npcEspEnabled = v
            if v then
                if not npcEspLoop then
                    npcEspLoop = game:GetService("RunService").RenderStepped:Connect(updateNpcESP)
                end
            else
                if npcEspLoop then
                    npcEspLoop:Disconnect()
                    npcEspLoop = nil
                end
                for model, esp in pairs(npcEspCache) do
                    for _, obj in pairs(esp) do
                        pcall(function() obj:Remove() end)
                    end
                end
                table.clear(npcEspCache)
            end
        end
    })
    
    -- å…¶ä»–æ ‡ç­¾é¡µä¿æŒä¸å˜...
    -- [æ­¤å¤„ä¿ç•™åŸæœ‰çš„å…¶ä»–æ ‡ç­¾é¡µä»£ç ]
    
    -- å¿è€…æ³¨å…¥å™¨å…¼å®¹æ€§æ£€æŸ¥
    if identifyexecutor and identifyexecutor():lower():find("ninja") then
        Rayfield:Notify({
            Title = "æ³¨å…¥å™¨æ£€æµ‹",
            Content = "å¿è€…æ³¨å…¥å™¨å·²è¯†åˆ«ï¼Œæ‰€æœ‰åŠŸèƒ½å…¼å®¹",
            Duration = 3,
            Image = 4483362458
        })
    end
    
    -- éªŒè¯é€šè¿‡åæ’­æ”¾åŠ¨ç”»
    CreateKunKunAnimation()
end

-- ç›´æ¥åˆ›å»ºä¸»çª—å£å†…å®¹
CreateMainWindowContent()

-- å¯åŠ¨ESPå’ŒNPCé€è§†å¾ªç¯
local espLoop = game:GetService("RunService").RenderStepped:Connect(updateESP)
local npcEspLoop = game:GetService("RunService").RenderStepped:Connect(updateNpcESP)