(function()
    -- 强制 200×200 居中窗口
    getgenv().WindowSize = UDim2.new(0, 200, 0, 200)
    
    -- 黑色 OrionLib UI
    local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/wsomoQaz/lua-/main/Xcccc"))()
    
    -- 卡密系统配置
    local KeySystem = {
        CurrentKey = nil,
        IsVerified = false,
        KeyFile = "StitchKey.txt",
        DiscordWebhook = "https://discord.com/api/webhooks/你的webhook地址",
        ValidKeys = {
            "2025",
            "666",
            "KUNKUN666",
            "666free",
            "TAIYOUYISILE"
        }
    }
    
    -- 纯黑主题
    OrionLib.Themes.Default = {
        Main    = Color3.fromRGB(20,20,20),
        Second  = Color3.fromRGB(30,30,30),
        Stroke  = Color3.fromRGB(50,50,50),
        Divider = Color3.fromRGB(40,40,40),
        Text    = Color3.fromRGB(255,255,255),
        TextDark= Color3.fromRGB(200,200,200)
    }
    OrionLib.SelectedTheme = "Default"
    
    -- 保存卡密到文件
    local function SaveKey(key)
        if writefile then
            writefile(KeySystem.KeyFile, key)
        end
    end
    
    -- 从文件读取卡密
    local function LoadKey()
        if isfile and isfile(KeySystem.KeyFile) then
            return readfile(KeySystem.KeyFile)
        end
        return nil
    end
    
    -- 验证卡密
    local function VerifyKey(key)
        if not key or key == "" then return false end
        
        for _, validKey in ipairs(KeySystem.ValidKeys) do
            if key == validKey then
                return true
            end
        end
        
        if syn and KeySystem.DiscordWebhook ~= "https://discord.com/api/webhooks/你的webhook地址" then
            syn.request({
                Url = KeySystem.DiscordWebhook,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = game:GetService("HttpService"):JSONEncode({
                    content = "尝试使用无效卡密: " .. key,
                    username = "Key System Logger"
                })
            })
        end
        
        return false
    end
    
    -- 复制到剪贴板函数
    local function CopyToClipboard(text)
        if setclipboard then
            setclipboard(text)
            return true
        elseif writeclipboard then
            writeclipboard(text)
            return true
        elseif toclipboard then
            toclipboard(text)
            return true
        else
            print("[复制内容] " .. text)
            return false
        end
    end
    
    -- 显示复制成功通知
    local function ShowCopyNotification(success, content)
        if success then
            OrionLib:MakeNotification({
                Name = "复制成功",
                Content = "已复制到剪贴板: " .. content,
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "复制失败",
                Content = "请手动复制控制台中的内容",
                Time = 5
            })
        end
    end

    -- 显示卡密验证窗口
    local function ShowKeyWindow()
        local KeyWindow = OrionLib:MakeWindow({
            Name = "卡密验证系统",
            HidePremium = true,
            SaveConfig = false,
            IntroEnabled = false
        })
        
        local KeyTab = KeyWindow:MakeTab({
            Name = "验证",
            Icon = "rbxassetid://4370345174"
        })
        
        KeyTab:AddLabel("请输入您的卡密以继续使用脚本")
        KeyTab:AddParagraph("注意", "卡密区分大小写，请确保输入正确")
        
        local KeyBox = KeyTab:AddTextbox({
            Name = "输入卡密",
            Default = "",
            TextDisappear = false,
            Callback = function(Value)
                KeySystem.CurrentKey = Value
            end
        })
        
        KeyTab:AddButton({
            Name = "验证卡密",
            Callback = function()
                if KeySystem.CurrentKey and VerifyKey(KeySystem.CurrentKey) then
                    KeySystem.IsVerified = true
                    SaveKey(KeySystem.CurrentKey)
                    
                    OrionLib:MakeNotification({
                        Name = "验证成功",
                        Content = "卡密验证通过，欢迎使用脚本！",
                        Time = 3
                    })
                    
                    KeyWindow:Destroy()
                    
                    -- 创建坤坤大帝脚本动画
                    CreateKunKunAnimation()
                    
                    -- 延迟后显示主窗口
                    wait(2.5)
                    ShowMainWindow()
                else
                    OrionLib:MakeNotification({
                        Name = "验证失败",
                        Content = "卡密无效或已过期，请重试！",
                        Time = 3
                    })
                end
            end
        })
        
        KeyTab:AddButton({
            Name = "获取卡密",
            Callback = function()
                OrionLib:MakeNotification({
                    Name = "获取卡密",
                    Content = "请加入Discord: https://discord.gg/xVUf7H9M",
                    Time = 5
                })
            end
        })
        
        -- 添加一键复制按钮
        KeyTab:AddButton({
            Name = "一键复制当前卡密",
            Callback = function()
                if KeySystem.CurrentKey and KeySystem.CurrentKey ~= "" then
                    local success = CopyToClipboard(KeySystem.CurrentKey)
                    ShowCopyNotification(success, KeySystem.CurrentKey)
                else
                    OrionLib:MakeNotification({
                        Name = "复制失败",
                        Content = "当前没有卡密可复制",
                        Time = 3
                    })
                end
            end
        })
        
        -- 添加一键复制Discord链接按钮
        KeyTab:AddButton({
            Name = "一键复制Discord链接",
            Callback = function()
                local discordLink = "https://discord.gg/xVUf7H9M"
                local success = CopyToClipboard(discordLink)
                ShowCopyNotification(success, discordLink)
            end
        })
        
        -- 自动填充已保存的卡密
        local savedKey = LoadKey()
        if savedKey then
            KeyBox:Set(savedKey)
            KeySystem.CurrentKey = savedKey
        end
    end
    
    -- 坤坤大帝脚本弹性动画 (5秒版本)
    local function CreateKunKunAnimation()
        -- 创建全屏背景
        local bg = Drawing.new("Square")
        bg.Size = workspace.CurrentCamera.ViewportSize
        bg.Position = Vector2.new(0, 0)
        bg.Color = Color3.new(0, 0, 0)
        bg.Filled = true
        bg.Transparency = 1
        bg.Visible = true
        bg.ZIndex = 999
        
        -- 创建坤坤大帝文字
        local text = Drawing.new("Text")
        text.Text = "坤坤大帝脚本"
        text.Size = 100
        text.Center = true
        text.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2, -200)
        text.Color = Color3.new(1, 0.2, 0.2)
        text.Outline = true
        text.OutlineColor = Color3.new(1, 1, 1)
        text.Transparency = 0
        text.Visible = true
        text.ZIndex = 1000
        
        -- 创建副标题
        local subText = Drawing.new("Text")
        subText.Text = "尊享特权版 - 启动成功"
        subText.Size = 40
        subText.Center = true
        subText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2, -100)
        subText.Color = Color3.new(0.8, 0.8, 1)
        subText.Outline = true
        subText.OutlineColor = Color3.new(0.2, 0.2, 0.2)
        subText.Transparency = 0
        subText.Visible = true
        subText.ZIndex = 1000
        
        -- 弹性动画函数
        local function elasticAnimation(obj, targetY, duration)
            local startY = obj.Position.Y
            local startTime = tick()
            local damping = 0.7
            local stiffness = 0.3
            
            local connection
            connection = game:GetService("RunService").RenderStepped:Connect(function()
                local elapsed = tick() - startTime
                local progress = elapsed / duration
                
                if progress >= 1 then
                    obj.Position = Vector2.new(obj.Position.X, targetY)
                    connection:Disconnect()
                    return
                end
                
                local overshoot = math.sin(progress * math.pi * 4) * (1 - progress)
                local newY = targetY + (startY - targetY) * math.pow(1 - progress, 2) * overshoot * stiffness
                stiffness = stiffness * damping
                obj.Position = Vector2.new(obj.Position.X, newY)
            end)
        end
        
        spawn(function()
            -- 背景淡入
            for i = 0, 1, 0.05 do
                bg.Transparency = 1 - i * 0.7
                wait(0.01)
            end
            
            -- 主标题弹性下落
            elasticAnimation(text, workspace.CurrentCamera.ViewportSize.Y/2 - 100, 1.5)
            
            -- 副标题延迟0.2秒后弹性下落
            wait(0.2)
            elasticAnimation(subText, workspace.CurrentCamera.ViewportSize.Y/2 + 20, 1.3)
            
            -- 总停留时间5秒
            wait(3.5)
            
            -- 淡出动画
            for i = 0, 1, 0.05 do
                text.Transparency = i
                subText.Transparency = i
                bg.Transparency = 0.3 + i * 0.7
                wait(0.01)
            end
            
            -- 移除绘图对象
            bg:Remove()
            text:Remove()
            subText:Remove()
        end)
    end

    -- 通用Aimbot系统
    local UniversalAimbot = {
        Enabled = false,
        SilentAim = false,
        TargetNPCs = true,
        FOV = 120,
        Smoothness = 0.3,
        HitChance = 95,
        Prediction = 0.12,
        BonePriority = {"Head", "UpperTorso", "HumanoidRootPart"},
        LastShot = 0,
        ShotDelay = 0.1,
        TargetCache = {},
        CacheTTL = 0.5, -- 缓存有效期（秒）
        LastCacheUpdate = 0,
        
        -- 更新目标缓存（减少每帧计算量）
        UpdateTargetCache = function(self)
            if tick() - self.LastCacheUpdate < self.CacheTTL then return end
            
            self.TargetCache = {}
            local localChar = game.Players.LocalPlayer.Character
            if not localChar then return end
            
            -- 获取玩家目标
            for _, player in ipairs(game.Players:GetPlayers()) do
                if player == game.Players.LocalPlayer then continue end
                
                local char = player.Character
                if char and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0 then
                    table.insert(self.TargetCache, {
                        Type = "Player",
                        Character = char,
                        Player = player
                    })
                end
            end
            
            -- 获取NPC目标
            if self.TargetNPCs then
                for _, model in ipairs(workspace:GetChildren()) do
                    if model:IsA("Model") and model ~= localChar then
                        local humanoid = model:FindFirstChildOfClass("Humanoid")
                        if humanoid and humanoid.Health > 0 then
                            table.insert(self.TargetCache, {
                                Type = "NPC",
                                Character = model,
                                Humanoid = humanoid
                            })
                        end
                    end
                end
            end
            
            self.LastCacheUpdate = tick()
        end,
        
        -- 获取最佳目标
        GetBestTarget = function(self)
            self:UpdateTargetCache()
            
            local bestTarget, bestScore = nil, -math.huge
            local localPos = workspace.CurrentCamera.CFrame.Position
            local mousePos = Vector2.new(game:GetService("UserInputService"):GetMouseLocation().X, game:GetService("UserInputService"):GetMouseLocation().Y)
            
            for _, target in ipairs(self.TargetCache) do
                local char = target.Character
                
                -- 找到最佳骨骼
                local bestBone, bestBonePos = nil, nil
                for _, boneName in ipairs(self.BonePriority) do
                    local bone = char:FindFirstChild(boneName)
                    if bone then
                        bestBone = bone
                        bestBonePos = bone.Position
                        break
                    end
                end
                
                if bestBone then
                    -- 计算屏幕位置
                    local screenPos, onScreen = workspace.CurrentCamera:WorldToScreenPoint(bestBonePos)
                    if onScreen then
                        -- 计算距离分数
                        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                        local inFOV = screenDist <= self.FOV
                        
                        -- 计算威胁分数（距离 + 血量）
                        local distance = (localPos - bestBonePos).Magnitude
                        local healthScore = target.Humanoid and (100 - target.Humanoid.Health/10) or 0
                        local score = (1000 / distance) + healthScore
                        
                        if inFOV and score > bestScore then
                            -- 应用预测
                            local rootPart = char:FindFirstChild("HumanoidRootPart")
                            if rootPart then
                                bestBonePos = bestBonePos + (rootPart.Velocity * self.Prediction)
                            end
                            
                            bestTarget = {
                                Part = bestBone,
                                Position = bestBonePos,
                                Character = char
                            }
                            bestScore = score
                        end
                    end
                end
            end
            
            return bestTarget
        end,
        
        -- 瞄准目标
        AimAtTarget = function(self, target)
            if not target or tick() - self.LastShot < self.ShotDelay then return end
            if math.random(1, 100) > self.HitChance then return end
            
            local camera = workspace.CurrentCamera
            local targetDir = (target.Position - camera.CFrame.Position).Unit
            
            -- 平滑瞄准
            local currentLook = camera.CFrame.LookVector
            local newLook = currentLook:Lerp(targetDir, self.Smoothness)
            
            camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + newLook)
            
            -- 模拟射击
            mouse1press()
            task.wait(0.05)
            mouse1release()
            self.LastShot = tick()
        end,
        
        -- Silent Aim核心
        HookSilentAim = function(self)
            local mt = getrawmetatable(game)
            local oldIndex = mt.__index
            setreadonly(mt, false)
            
            mt.__index = newcclosure(function(t, k)
                if k == "Hit" and self.SilentAim then
                    local target = self:GetBestTarget()
                    if target then
                        return target.Part.CFrame + Vector3.new(
                            (math.random() - 0.5) * 0.2,
                            math.random() * 0.1,
                            (math.random() - 0.5) * 0.2
                        )
                    end
                end
                return oldIndex(t, k)
            end)
            
            setreadonly(mt, true)
        end,
        
        -- 帧率优化器
        FrameOptimizer = function(self)
            local frameCounter = 0
            local lastFrameTime = tick()
            local targetFPS = 60
            
            game:GetService("RunService").RenderStepped:Connect(function()
                frameCounter = frameCounter + 1
                
                -- 每60帧计算一次FPS
                if frameCounter >= 60 then
                    local elapsed = tick() - lastFrameTime
                    local currentFPS = frameCounter / elapsed
                    
                    -- 动态调整计算频率
                    if currentFPS < targetFPS then
                        self.CacheTTL = math.min(1.0, self.CacheTTL + 0.05)
                    else
                        self.CacheTTL = math.max(0.1, self.CacheTTL - 0.02)
                    end
                    
                    frameCounter = 0
                    lastFrameTime = tick()
                end
                
                -- 执行瞄准
                if self.Enabled then
                    local target = self:GetBestTarget()
                    if target then
                        self:AimAtTarget(target)
                    end
                end
            end)
        end
    }

    -- 初始化通用Aimbot
    UniversalAimbot:HookSilentAim()
    UniversalAimbot:FrameOptimizer()

    -- 显示主窗口（验证通过后）
    local function ShowMainWindow()
        -- 主窗口
        local Window = OrionLib:MakeWindow({
            IntroText = "坤坤大帝脚本",
            Name = "坤坤大帝脚本 - " .. identifyexecutor(),
            HidePremium = false,
            SaveConfig = true,
            ConfigFolder = "StitchConfig"
        })
        
        -- 公告 Tab
        local Tab1 = Window:MakeTab({Name = "公告", Icon = "rbxassetid://7733779610"})
        local function getDate() return os.date("%Y-%m-%d %H:%M") end
        local function getPlayer()
            local p = game.Players.LocalPlayer
            return {
                ["用户名"]   = p.Name,
                ["显示名"]   = p.DisplayName,
                ["用户ID"]   = p.UserId,
                ["注册天数"] = p.AccountAge,
                ["当前游戏"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
            }
        end
        Tab1:AddLabel("📅 当前时间")
        Tab1:AddLabel(getDate())
        for k, v in pairs(getPlayer()) do
            Tab1:AddLabel(k .. "： " .. tostring(v))
        end
        
        -- 添加一键复制QQ号按钮
        Tab1:AddButton({
            Name = "一键复制QQ号", 
            Callback = function() 
                local success = CopyToClipboard("913348285")
                ShowCopyNotification(success, "913348285")
            end
        })
        
        -- 通用Aimbot设置
        local AimTab = Window:MakeTab({Name = "通用瞄准", Icon = "rbxassetid://7733779610"})
        
        AimTab:AddToggle({
            Name = "启用Aimbot", 
            Default = false, 
            Callback = function(v) 
                UniversalAimbot.Enabled = v 
            end
        })
        
        AimTab:AddToggle({
            Name = "启用Silent Aim", 
            Default = false, 
            Callback = function(v) 
                UniversalAimbot.SilentAim = v 
            end
        })
        
        AimTab:AddToggle({
            Name = "瞄准NPC", 
            Default = true, 
            Callback = function(v) 
                UniversalAimbot.TargetNPCs = v 
            end
        })
        
        AimTab:AddTextbox({
            Name = "骨骼优先级 (用逗号分隔)",
            Default = table.concat(UniversalAimbot.BonePriority, ","),
            Callback = function(txt)
                local bones = {}
                for bone in string.gmatch(txt, "[^,]+") do
                    table.insert(bones, bone:match("^%s*(.-)%s*$"))
                end
                if #bones > 0 then UniversalAimbot.BonePriority = bones end
            end
        })
        
        AimTab:AddSlider({
            Name = "FOV半径",
            Min = 10,
            Max = 500,
            Default = UniversalAimbot.FOV,
            Increment = 5,
            Callback = function(v)
                UniversalAimbot.FOV = v
            end
        })
        
        AimTab:AddSlider({
            Name = "平滑度 (0.1-1)",
            Min = 0.1,
            Max = 1,
            Default = UniversalAimbot.Smoothness,
            Increment = 0.01,
            Callback = function(v)
                UniversalAimbot.Smoothness = v
            end
        })
        
        AimTab:AddSlider({
            Name = "命中率 (1-100)",
            Min = 1,
            Max = 100,
            Default = UniversalAimbot.HitChance,
            Increment = 1,
            Callback = function(v)
                UniversalAimbot.HitChance = v
            end
        })
        
        AimTab:AddSlider({
            Name = "预测值 (0-0.5)",
            Min = 0,
            Max = 0.5,
            Default = UniversalAimbot.Prediction,
            Increment = 0.01,
            Callback = function(v)
                UniversalAimbot.Prediction = v
            end
        })
        
        AimTab:AddSlider({
            Name = "射击延迟 (秒)",
            Min = 0.05,
            Max = 1,
            Default = UniversalAimbot.ShotDelay,
            Increment = 0.01,
            Callback = function(v)
                UniversalAimbot.ShotDelay = v
            end
        })
        
        -- 性能优化设置
        local PerfTab = Window:MakeTab({Name = "性能优化", Icon = "rbxassetid://7733779610"})
        
        PerfTab:AddToggle({
            Name = "删除阴影",
            Default = false,
            Callback = function(v)
                game.Lighting.GlobalShadows = not v
                for _, l in ipairs(workspace:GetDescendants()) do
                    if l:IsA("BasePart") or l:IsA("MeshPart") then
                        l.CastShadow = not v
                    end
                end
                OrionLib:MakeNotification({Name = "提示", Content = v and "阴影已删除" or "阴影已恢复", Time = 2})
            end
        })
        
        PerfTab:AddToggle({
            Name = "降低渲染质量",
            Default = false,
            Callback = function(v)
                if v then
                    settings().Rendering.QualityLevel = 1
                    game:GetService("Lighting").GlobalShadows = false
                    game:GetService("Lighting").Technology = "ShadowMap"
                else
                    settings().Rendering.QualityLevel = 21
                    game:GetService("Lighting").GlobalShadows = true
                    game:GetService("Lighting").Technology = "Voxel"
                end
            end
        })
        
        PerfTab:AddSlider({
            Name = "最大粒子数",
            Min = 100,
            Max = 5000,
            Default = 1000,
            Callback = function(v)
                settings().Rendering.MaxParticleCount = v
            end
        })
        
        -- 其他功能
        local MiscTab = Window:MakeTab({Name = "其他功能", Icon = "rbxassetid://7733779610"})
        
        MiscTab:AddButton({
            Name = "飞行模式",
            Callback = function()
                loadstring(game:HttpGet("https://raw.githubusercontent.com/XNEOFF/FlyGuiV3/main/FlyGuiV3.txt"))()
            end
        })
        
        MiscTab:AddButton({
            Name = "穿墙模式",
            Callback = function()
                local Char = game.Players.LocalPlayer.Character
                if Char then
                    for _, part in ipairs(Char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                    OrionLib:MakeNotification({Name = "提示", Content = "穿墙模式已激活", Time = 3})
                end
            end
        })
        
        -- 设置Tab - 卡密管理
        local SettingsTab = Window:MakeTab({Name = "设置", Icon = "rbxassetid://7733779610"})
        SettingsTab:AddButton({
            Name = "清除卡密",
            Callback = function()
                if isfile and isfile(KeySystem.KeyFile) then
                    delfile(KeySystem.KeyFile)
                    OrionLib:MakeNotification({
                        Name = "成功",
                        Content = "卡密已清除，请重新验证",
                        Time = 3
                    })
                    Window:Destroy()
                    wait(1)
                    ShowKeyWindow()
                end
            end
        })
        
        SettingsTab:AddLabel("卡密状态: " .. (KeySystem.CurrentKey and "已验证" or "未验证"))
        SettingsTab:AddLabel("当前卡密: " .. (KeySystem.CurrentKey or "无"))
        
        -- 添加一键复制卡密按钮
        SettingsTab:AddButton({
            Name = "一键复制当前卡密",
            Callback = function()
                if KeySystem.CurrentKey and KeySystem.CurrentKey ~= "" then
                    local success = CopyToClipboard(KeySystem.CurrentKey)
                    ShowCopyNotification(success, KeySystem.CurrentKey)
                else
                    OrionLib:MakeNotification({
                        Name = "复制失败",
                        Content = "当前没有卡密可复制",
                        Time = 3
                    })
                end
            end
        })
        
        -- 添加一键复制Discord链接按钮
        SettingsTab:AddButton({
            Name = "一键复制Discord链接",
            Callback = function()
                local discordLink = "https://discord.gg/xVUf7H9M"
                local success = CopyToClipboard(discordLink)
                ShowCopyNotification(success, discordLink)
            end
        })
        
        -- 启动
        OrionLib:Init()
    end
    
    -- 主逻辑：检查是否有已验证的卡密
    local savedKey = LoadKey()
    if savedKey and VerifyKey(savedKey) then
        KeySystem.CurrentKey = savedKey
        KeySystem.IsVerified = true
        
        -- 创建坤坤大帝脚本动画
        CreateKunKunAnimation()
        
        -- 延迟后显示主窗口
        wait(2.5)
        ShowMainWindow()
    else
        -- 清除无效的已保存卡密
        if isfile and isfile(KeySystem.KeyFile) then
            delfile(KeySystem.KeyFile)
        end
        ShowKeyWindow()
    end
    
    -- 忍者注入器兼容性检查
    if identifyexecutor and identifyexecutor():lower():find("ninja") then
        OrionLib:MakeNotification({
            Name = "注入器检测",
            Content = "忍者注入器已识别，卡密系统已适配",
            Time = 3
        })
    end
    
    -- 添加卡密管理命令（可选）
    getgenv().SetKey = function(key)
        if VerifyKey(key) then
            KeySystem.CurrentKey = key
            KeySystem.IsVerified = true
            SaveKey(key)
            OrionLib:MakeNotification({
                Name = "成功",
                Content = "卡密已通过命令设置",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "失败",
                Content = "无效的卡密",
                Time = 2
            })
        end
    end
    
    getgenv().ClearKey = function()
        if isfile and isfile(KeySystem.KeyFile) then
            delfile(KeySystem.KeyFile)
            KeySystem.IsVerified = false
            OrionLib:MakeNotification({
                Name = "成功",
                Content = "卡密已清除",
                Time = 2
            })
        end
    end
end)()