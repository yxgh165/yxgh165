-- 修复远程事件错误的核心代码
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- 确保正确处理远程事件
local function setupRemoteEvents()
    local remoteEvent = ReplicatedStorage:FindFirstChild("SendLikelySpeakingUsers")
    if remoteEvent then
        remoteEvent.OnClientEvent:Connect(function(...)
            -- 添加你的事件处理逻辑
            print("处理远程事件:", ...)
        end)
    else
        warn("未找到 SendLikelySpeakingUsers 远程事件")
    end
end

-- 安全执行主脚本
local function main()
    -- 强制 200×200 居中窗口
    getgenv().WindowSize = UDim2.new(0, 200, 0, 200)
    
    -- 黑色 OrionLib UI (添加备用加载方式防止服务器拦截)
    local OrionLib
    local success, err = pcall(function()
        OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/wsomoQaz/lua-/main/Xcccc"))()
    end)
    
    if not success then
        -- 如果主链接失败，尝试备用链接
        success, err = pcall(function()
            OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/shlexware/Orion/main/source"))()
        end)
        
        if not success then
            -- 如果两个链接都失败，使用本地注入方式
            OrionLib = loadstring(game:HttpGet(("https://gist.githubusercontent.com/AsianGod14/3d4f0c3d7e0b5b3f3e3b/raw/4e3b7d0c3d7e0b5b3f3e3b4e3b7d0c3d7e0b5b3f3e3b.lua")))()
        end
    end
    
    -- 卡密系统配置 (兼容忍者注入器)
    local KeySystem = {
        CurrentKey = nil,
        IsVerified = false,
        KeyFile = "StitchKey.txt",
        DiscordWebhook = "https://discord.com/api/webhooks/你的webhook地址",
        ValidKeys = {
            "2025",
            "666",
            "KUNKUN666",
            "666free",
            "TAIYOUYISILE"
        },
        StorageMethod = "Global" -- 默认使用全局变量存储
    }
    
    -- 检测执行器类型
    local function identifyExecutor()
        local exec = "Unknown"
        if syn then exec = "Synapse" end
        if KRNL_LOADED then exec = "Krnl" end
        if fluxus then exec = "Fluxus" end
        if is_sirhurt_closure then exec = "SirHurt" end
        if identifyexecutor and identifyexecutor():lower():find("ninja") then
            exec = "Ninja"
            KeySystem.StorageMethod = "Global" -- 忍者注入器使用全局变量
        end
        return exec
    end
    
    -- 纯黑主题
    OrionLib.Themes.Default = {
        Main    = Color3.fromRGB(20,20,20),
        Second  = Color3.fromRGB(30,30,30),
        Stroke  = Color3.fromRGB(50,50,50),
        Divider = Color3.fromRGB(40,40,40),
        Text    = Color3.fromRGB(255,255,255),
        TextDark= Color3.fromRGB(200,200,200)
    }
    OrionLib.SelectedTheme = "Default"
    
    -- 保存卡密
    local function SaveKey(key)
        if KeySystem.StorageMethod == "File" and writefile then
            writefile(KeySystem.KeyFile, key)
        else
            getgenv().StitchSavedKey = key
        end
    end
    
    -- 读取卡密
    local function LoadKey()
        if KeySystem.StorageMethod == "File" and isfile and isfile(KeySystem.KeyFile) then
            return readfile(KeySystem.KeyFile)
        elseif getgenv().StitchSavedKey then
            return getgenv().StitchSavedKey
        end
        return nil
    end
    
    -- 验证卡密
    local function VerifyKey(key)
        if not key or key == "" then return false end
        
        for _, validKey in ipairs(KeySystem.ValidKeys) do
            if key == validKey then
                return true
            end
        end
        
        return false
    end
    
    -- 复制到剪贴板 (兼容多种执行器)
    local function CopyToClipboard(text)
        if setclipboard then
            setclipboard(text)
            return true
        elseif writeclipboard then
            writeclipboard(text)
            return true
        elseif toclipboard then
            toclipboard(text)
            return true
        else
            print("[复制内容] " .. text)
            return false
        end
    end
    
    -- 显示复制成功通知
    local function ShowCopyNotification(success, content)
        if success then
            OrionLib:MakeNotification({
                Name = "复制成功",
                Content = "已复制到剪贴板: " .. content,
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "复制失败",
                Content = "请手动复制控制台中的内容",
                Time = 5
            })
        end
    end

    -- 显示卡密验证窗口
    local function ShowKeyWindow()
        local KeyWindow = OrionLib:MakeWindow({
            Name = "卡密验证系统",
            HidePremium = true,
            SaveConfig = false,
            IntroEnabled = false
        })
        
        local KeyTab = KeyWindow:MakeTab({
            Name = "验证",
            Icon = "rbxassetid://4370345174"
        })
        
        KeyTab:AddLabel("执行器: "..identifyExecutor())
        KeyTab:AddLabel("请输入您的卡密以继续使用脚本")
        KeyTab:AddParagraph("注意", "卡密区分大小写，请确保输入正确")
        
        local KeyBox = KeyTab:AddTextbox({
            Name = "输入卡密",
            Default = "",
            TextDisappear = false,
            Callback = function(Value)
                KeySystem.CurrentKey = Value
            end
        })
        
        KeyTab:AddButton({
            Name = "验证卡密",
            Callback = function()
                if KeySystem.CurrentKey and VerifyKey(KeySystem.CurrentKey) then
                    KeySystem.IsVerified = true
                    SaveKey(KeySystem.CurrentKey)
                    
                    OrionLib:MakeNotification({
                        Name = "验证成功",
                        Content = "卡密验证通过，欢迎使用脚本！",
                        Time = 3
                    })
                    
                    KeyWindow:Destroy()
                    
                    -- 创建坤坤大帝脚本动画
                    CreateKunKunAnimation()
                    
                    -- 延迟后显示主窗口
                    task.wait(2.5)
                    ShowMainWindow()
                else
                    OrionLib:MakeNotification({
                        Name = "验证失败",
                        Content = "卡密无效或已过期，请重试！",
                        Time = 3
                    })
                end
            end
        })
        
        KeyTab:AddButton({
            Name = "获取卡密",
            Callback = function()
                OrionLib:MakeNotification({
                    Name = "获取卡密",
                    Content = "请加入Discord: https://discord.gg/xVUf7H9M",
                    Time = 5
                })
            end
        })
        
        -- 添加一键复制按钮
        KeyTab:AddButton({
            Name = "一键复制当前卡密",
            Callback = function()
                if KeySystem.CurrentKey and KeySystem.CurrentKey ~= "" then
                    local success = CopyToClipboard(KeySystem.CurrentKey)
                    ShowCopyNotification(success, KeySystem.CurrentKey)
                else
                    OrionLib:MakeNotification({
                        Name = "复制失败",
                        Content = "当前没有卡密可复制",
                        Time = 3
                    })
                end
            end
        })
        
        KeyTab:AddButton({
            Name = "一键复制Discord链接",
            Callback = function()
                local discordLink = "https://discord.gg/xVUf7H9M"
                local success = CopyToClipboard(discordLink)
                ShowCopyNotification(success, discordLink)
            end
        })
        
        -- 自动填充已保存的卡密
        local savedKey = LoadKey()
        if savedKey then
            KeyBox:Set(savedKey)
            KeySystem.CurrentKey = savedKey
        end
    end
    
    -- 坤坤大帝脚本弹性动画
    local function CreateKunKunAnimation()
        -- 创建全屏背景
        local bg = Drawing.new("Square")
        bg.Size = workspace.CurrentCamera.ViewportSize
        bg.Position = Vector2.new(0, 0)
        bg.Color = Color3.new(0, 0, 0)
        bg.Filled = true
        bg.Transparency = 1
        bg.Visible = true
        bg.ZIndex = 999
        
        -- 创建坤坤大帝文字
        local text = Drawing.new("Text")
        text.Text = "坤坤大帝脚本"
        text.Size = 100
        text.Center = true
        text.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2, -200)
        text.Color = Color3.new(1, 0.2, 0.2)
        text.Outline = true
        text.OutlineColor = Color3.new(1, 1, 1)
        text.Transparency = 0
        text.Visible = true
        text.ZIndex = 1000
        
        -- 创建副标题
        local subText = Drawing.new("Text")
        subText.Text = "尊享特权版 - 启动成功"
        subText.Size = 40
        subText.Center = true
        subText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X/2, -100)
        subText.Color = Color3.new(0.8, 0.8, 1)
        subText.Outline = true
        subText.OutlineColor = Color3.new(0.2, 0.2, 0.2)
        subText.Transparency = 0
        subText.Visible = true
        subText.ZIndex = 1000
        
        -- 弹性动画函数
        local function elasticAnimation(obj, targetY, duration)
            local startY = obj.Position.Y
            local startTime = tick()
            local damping = 0.7
            local stiffness = 0.3
            
            local connection
            connection = game:GetService("RunService").RenderStepped:Connect(function()
                local elapsed = tick() - startTime
                local progress = elapsed / duration
                
                if progress >= 1 then
                    obj.Position = Vector2.new(obj.Position.X, targetY)
                    connection:Disconnect()
                    return
                end
                
                local overshoot = math.sin(progress * math.pi * 4) * (1 - progress)
                local newY = targetY + (startY - targetY) * math.pow(1 - progress, 2) * overshoot * stiffness
                stiffness = stiffness * damping
                
                obj.Position = Vector2.new(obj.Position.X, newY)
            end)
        end
        
        task.spawn(function()
            -- 背景淡入
            for i = 0, 1, 0.05 do
                bg.Transparency = 1 - i * 0.7
                task.wait(0.01)
            end
            
            -- 主标题弹性下落
            elasticAnimation(text, workspace.CurrentCamera.ViewportSize.Y/2 - 100, 1.5)
            
            -- 副标题延迟后弹性下落
            task.wait(0.2)
            elasticAnimation(subText, workspace.CurrentCamera.ViewportSize.Y/2 + 20, 1.3)
            
            -- 总停留时间5秒
            task.wait(3.5)
            
            -- 淡出动画
            for i = 0, 1, 0.05 do
                text.Transparency = i
                subText.Transparency = i
                bg.Transparency = 0.3 + i * 0.7
                task.wait(0.01)
            end
            
            -- 移除绘图对象
            bg:Remove()
            text:Remove()
            subText:Remove()
        end)
    end

    -- 显示主窗口（验证通过后）
    local function ShowMainWindow()
        -- 主窗口
        local Window = OrionLib:MakeWindow({
            IntroText = "坤坤大帝脚本",
            Name = "坤坤大帝脚本 - "..identifyExecutor(),
            HidePremium = false,
            SaveConfig = true,
            ConfigFolder = "StitchConfig"
        })
        
        -- 公告 Tab
        local Tab1 = Window:MakeTab({Name = "公告", Icon = "rbxassetid://7733779610"})
        local function getDate() return os.date("%Y-%m-%d %H:%M") end
        local function getPlayer()
            local p = game.Players.LocalPlayer
            return {
                ["用户名"]   = p.Name,
                ["显示名"]   = p.DisplayName,
                ["用户ID"]   = p.UserId,
                ["注册天数"] = p.AccountAge,
                ["当前游戏"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
            }
        end
        Tab1:AddLabel("📅 当前时间")
        Tab1:AddLabel(getDate())
        for k, v in pairs(getPlayer()) do
            Tab1:AddLabel(k .. "： " .. tostring(v))
        end
        
        Tab1:AddButton({
            Name = "一键复制QQ号", 
            Callback = function() 
                local success = CopyToClipboard("913348285")
                ShowCopyNotification(success, "913348285")
            end
        })
        
        -- 人物功能 Tab
        local Tab4 = Window:MakeTab({Name = "人物功能", Icon = "rbxassetid://7733779610"})
        
        -- 鼠标模拟函数 (兼容忍者注入器)
        local mouse1press, mouse1release
        if mousemoverel then
            mouse1press = function()
                local vim = game:GetService("VirtualInputManager")
                vim:SendMouseButtonEvent(0,0,0,true,game,1)
            end
            mouse1release = function()
                local vim = game:GetService("VirtualInputManager")
                vim:SendMouseButtonEvent(0,0,0,false,game,1)
            end
        else
            mouse1press = mouse1press or function() end
            mouse1release = mouse1release or function() end
        end
        
        -----------------------------------------------------------------
        -- 双独立 FOV（修复版）
        -----------------------------------------------------------------
        -- 通用参数
        local aimbotEnabled      = false
        local aimbotSmooth       = 0.35
        local aimbotBone         = "Head"
        local aimbotPrediction   = 0.12
        local aimbotDelay        = 0.08
        local aimbotCheckTeam    = false  -- 默认关闭仅瞄准敌人
        local aimbotMode         = "Distance" -- 距离瞄准模式
        local wallCheck          = true   -- 墙体检测默认开启
        local showAimLine        = false  -- 自瞄线条默认关闭
        local lastFire = 0
        local aimbotConn
        
        -- 缺失变量一次性补全
        local Camera = workspace.CurrentCamera
        local UserInputService = game:GetService("UserInputService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        
        -- 1. 跟随鼠标 FOV
        local mouseFOV      = 120
        local mouseFovCircle = Drawing.new("Circle")
        mouseFovCircle.NumSides  = 64
        mouseFovCircle.Radius    = mouseFOV
        mouseFovCircle.Thickness = 1.5
        mouseFovCircle.Color     = Color3.fromRGB(255,255,255)
        mouseFovCircle.Filled    = false
        mouseFovCircle.Visible   = false
        mouseFovCircle.ZIndex = 10
        
        -- 2. 固定中心 FOV
        local fixedFOV      = 90
        local fixedFovCircle = Drawing.new("Circle")
        fixedFovCircle.NumSides  = 64
        fixedFovCircle.Radius    = fixedFOV
        fixedFovCircle.Thickness = 1.5
        fixedFovCircle.Color     = Color3.fromRGB(255,165,0)
        fixedFovCircle.Filled    = false
        fixedFovCircle.Visible   = false
        fixedFovCircle.ZIndex = 9
        
        -- 固定圆中心一次设置
        local function setFixedCenter()
            local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            fixedFovCircle.Position = center
        end
        if Camera:GetPropertyChangedSignal then
            Camera:GetPropertyChangedSignal("ViewportSize"):Connect(setFixedCenter)
        end
        setFixedCenter()
        
        -- 自瞄线条
        local aimLine = Drawing.new("Line")
        aimLine.Visible = false
        aimLine.Color = Color3.fromRGB(255, 0, 0)
        aimLine.Thickness = 1
        aimLine.ZIndex = 11
        
        -- 玩家ESP方框
        local espBoxes = {}
        local espLines = {}
        local espEnabled = false
        local espOrigin = "Top" -- 线条起点: Top 或 Bottom
        
        -- 创建玩家ESP
        local function createEsp(player)
            if player == LocalPlayer then return end
            
            local box = Drawing.new("Square")
            box.Visible = false
            box.Color = Color3.fromRGB(255, 0, 0)
            box.Thickness = 1
            box.Filled = false
            box.ZIndex = 8
            
            local line = Drawing.new("Line")
            line.Visible = false
            line.Color = Color3.fromRGB(0, 255, 0)
            line.Thickness = 1
            line.ZIndex = 9
            
            espBoxes[player] = box
            espLines[player] = line
        end
        
        -- 更新玩家ESP
        local function updateEsp()
            for player, box in pairs(espBoxes) do
                if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local root = player.Character.HumanoidRootPart
                    local pos, onScreen = Camera:WorldToViewportPoint(root.Position)
                    
                    if onScreen then
                        local size = Vector2.new(50, 100) * (1 / pos.Z)
                        box.Size = size
                        box.Position = Vector2.new(pos.X - size.X / 2, pos.Y - size.Y / 2)
                        box.Visible = espEnabled
                        
                        -- 更新线条
                        local line = espLines[player]
                        if line then
                            if espOrigin == "Top" then
                                line.From = Vector2.new(pos.X, pos.Y - size.Y / 2)
                            else
                                line.From = Vector2.new(pos.X, pos.Y + size.Y / 2)
                            end
                            line.To = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                            line.Visible = espEnabled and showAimLine
                        end
                    else
                        box.Visible = false
                        if espLines[player] then
                            espLines[player].Visible = false
                        end
                    end
                else
                    box.Visible = false
                    if espLines[player] then
                        espLines[player].Visible = false
                    end
                end
            end
        end
        
        -- 清理ESP
        local function clearEsp()
            for _, box in pairs(espBoxes) do
                box:Remove()
            end
            for _, line in pairs(espLines) do
                line:Remove()
            end
            espBoxes = {}
            espLines = {}
        end
        
        -- 初始化ESP
        for _, player in ipairs(Players:GetPlayers()) do
            createEsp(player)
        end
        
        Players.PlayerAdded:Connect(createEsp)
        Players.PlayerRemoving:Connect(function(player)
            if espBoxes[player] then
                espBoxes[player]:Remove()
                espBoxes[player] = nil
            end
            if espLines[player] then
                espLines[player]:Remove()
                espLines[player] = nil
            end
        end)
        
        -- ESP更新循环
        game:GetService("RunService").RenderStepped:Connect(updateEsp)
        
        -- 工具函数
        local function getAimPos(character)
            if not character then return nil end
            local root = character:FindFirstChild("HumanoidRootPart")
            local bone = character:FindFirstChild(aimbotBone) or character:FindFirstChild("Head")
            if not (root and bone) then return nil end
            local vel = root.Velocity.Magnitude < 0.1 and Vector3.new(0,0,0) or root.Velocity
            return bone.Position + vel * aimbotPrediction
        end
        
        local function isVisible(pos, ignore)
            if not wallCheck then return true end
            
            local origin = Camera.CFrame.Position
            local direction = (pos - origin).Unit
            local ray = Ray.new(origin, direction * (origin - pos).Magnitude)
            local part, position = workspace:FindPartOnRayWithIgnoreList(ray, ignore or {LocalPlayer.Character})
            return part == nil or part:IsDescendantOf(LocalPlayer.Character)
        end
        
        -- 获取最近目标 (修复玩家站着不动时不瞄准的问题)
        local function getClosest()
            if not LocalPlayer.Character then return nil end
            
            local closestPlayer = nil
            local closestDistance = math.huge
            local closestAngle = math.huge
            local mousePos = UserInputService:GetMouseLocation()
            local cameraCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
                    if aimbotCheckTeam and player.Team == LocalPlayer.Team then
                        continue
                    end
                    
                    local aimPos = getAimPos(player.Character)
                    if not aimPos then continue end
                    
                    if not isVisible(aimPos, {LocalPlayer.Character, player.Character}) then
                        continue
                    end
                    
                    local screenPos, onScreen = Camera:WorldToViewportPoint(aimPos)
                    if not onScreen then continue end
                    
                    local screenVec = Vector2.new(screenPos.X, screenPos.Y)
                    
                    if aimbotMode == "Distance" then
                        -- 距离模式
                        local distance = (mousePos - screenVec).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    else
                        -- 准心模式
                        local angle = (cameraCenter - screenVec).Magnitude
                        if angle < closestAngle then
                            closestAngle = angle
                            closestPlayer = player
                        end
                    end
                end
            end
            
            return closestPlayer
        end
        
        -- 主循环（带防瞬甩）
        local function startAimbot()
            if aimbotConn then return end
            
            aimbotConn = game:GetService("RunService").RenderStepped:Connect(function()
                if not aimbotEnabled then 
                    aimLine.Visible = false
                    return 
                end
                
                -- 更新跟随圆
                mouseFovCircle.Position = UserInputService:GetMouseLocation()
        
                local target = getClosest()
                if not target or not target.Character then 
                    aimLine.Visible = false
                    return 
                end
                
                local aimPos = getAimPos(target.Character)
                if not aimPos then 
                    aimLine.Visible = false
                    return 
                end
        
                -- 更新自瞄线条
                if showAimLine then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(aimPos)
                    if onScreen then
                        aimLine.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                        aimLine.To = Vector2.new(screenPos.X, screenPos.Y)
                        aimLine.Visible = true
                    else
                        aimLine.Visible = false
                    end
                else
                    aimLine.Visible = false
                end
                
                -- 安全 + 角度限制
                local delta = aimPos - Camera.CFrame.Position
                if delta.Magnitude < 0.1 then return end
                
                local targetCF = CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + delta)
                local currentLook = Camera.CFrame.LookVector
                local targetLook = targetCF.LookVector
                
                local dot = currentLook:Dot(targetLook)
                local angle = math.acos(math.clamp(dot, -1, 1))
                local maxAngle = math.rad(90)
                
                if angle <= maxAngle then
                    local smoothFactor = math.clamp(aimbotSmooth, 0.01, 0.99)
                    local newLook = currentLook:Lerp(targetLook, 1 - smoothFactor)
                    Camera.CFrame = CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + newLook)
                end
        
                if tick() - lastFire > aimbotDelay then
                    mouse1press()
                    task.wait(0.05)
                    mouse1release()
                    lastFire = tick()
                end
            end)
        end
        
        local function stopAimbot()
            if aimbotConn then 
                aimbotConn:Disconnect() 
                aimbotConn = nil 
            end
            mouseFovCircle.Visible = false
            fixedFovCircle.Visible = false
            aimLine.Visible = false
        end
        
        -- UI 构建
        local aimbotSec = Tab4:AddSection({Name = "AI-Aimbot"})
        aimbotSec:AddToggle({
            Name = "启用 Aimbot",
            Default = false,
            Callback = function(v)
                aimbotEnabled = v
                if v then 
                    startAimbot() 
                else 
                    stopAimbot() 
                end
            end
        })
        aimbotSec:AddToggle({
            Name = "仅瞄准敌人",
            Default = aimbotCheckTeam,
            Callback = function(v) aimbotCheckTeam = v end
        })
        aimbotSec:AddToggle({
            Name = "墙体检测",
            Default = wallCheck,
            Callback = function(v) wallCheck = v end
        })
        aimbotSec:AddToggle({
            Name = "显示自瞄线条",
            Default = showAimLine,
            Callback = function(v) showAimLine = v end
        })
        aimbotSec:AddDropdown({
            Name = "瞄准模式",
            Default = aimbotMode,
            Options = {"Distance", "Angle"},
            Callback = function(v) aimbotMode = v end
        })
        
        local espSec = Tab4:AddSection({Name = "ESP设置"})
        espSec:AddToggle({
            Name = "启用ESP方框",
            Default = espEnabled,
            Callback = function(v) 
                espEnabled = v 
                if not v then
                    clearEsp()
                end
            end
        })
        espSec:AddDropdown({
            Name = "线条起点",
            Default = espOrigin,
            Options = {"Top", "Bottom"},
            Callback = function(v) espOrigin = v end
        })
        
        local mouseSec = Tab4:AddSection({Name = "跟随鼠标 FOV"})
        local mouseTog = mouseSec:AddToggle({ Name = "显示跟随FOV", Default = false, Callback = function(v) mouseFovCircle.Visible = v end })
        local mouseSlider = mouseSec:AddSlider({ Name = "半径（滑条）", Min = 0, Max = 500, Default = mouseFOV, Increment = 5, Callback = function(v) mouseFOV = v; mouseFovCircle.Radius = v end })
        mouseSec:AddTextbox({ Name = "半径（输入）", Default = tostring(mouseFOV), Callback = function(txt) local n = tonumber(txt) if n then mouseFOV = n; mouseFovCircle.Radius = n; mouseSlider:Set(n) end end })
        
        local fixedSec = Tab4:AddSection({Name = "固定中心 FOV"})
        local fixedTog = fixedSec:AddToggle({ Name = "显示固定FOV", Default = false, Callback = function(v) fixedFovCircle.Visible = v end })
        local fixedSlider = fixedSec:AddSlider({ Name = "半径（滑条）", Min = 0, Max = 500, Default = fixedFOV, Increment = 5, Callback = function(v) fixedFOV = v; fixedFovCircle.Radius = v end })
        fixedSec:AddTextbox({ Name = "半径（输入）", Default = tostring(fixedFOV), Callback = function(txt) local n = tonumber(txt) if n then fixedFOV = n; fixedFovCircle.Radius = n; fixedSlider:Set(n) end end })
        
        local commonSec = Tab4:AddSection({Name = "通用参数"})
        local smoothSlider = commonSec:AddSlider({ Name = "平滑系数（滑条）", Min = 0, Max = 1, Default = aimbotSmooth, Increment = 0.01, Callback = function(v) aimbotSmooth = v end })
        commonSec:AddTextbox({ Name = "平滑系数（输入）", Default = tostring(aimbotSmooth), Callback = function(txt) local n = tonumber(txt) if n then aimbotSmooth = n; smoothSlider:Set(n) end end })
        local predSlider = commonSec:AddSlider({ Name = "预测 (秒)（滑条）", Min = 0, Max = 1, Default = aimbotPrediction, Increment = 0.01, Callback = function(v) aimbotPrediction = v end })
        commonSec:AddTextbox({ Name = "预测 (秒)（输入）", Default = tostring(aimbotPrediction), Callback = function(txt) local n = tonumber(txt) if n then aimbotPrediction = n; predSlider:Set(n) end end })
        local delaySlider = commonSec:AddSlider({ Name = "开火延迟 (秒)（滑条）", Min = 0, Max = 1, Default = aimbotDelay, Increment = 0.01, Callback = function(v) aimbotDelay = v end })
        commonSec:AddTextbox({ Name = "开火延迟 (秒)（输入）", Default = tostring(aimbotDelay), Callback = function(txt) local n = tonumber(txt) if n then aimbotDelay = n; delaySlider:Set(n) end end })
        commonSec:AddDropdown({ Name = "瞄准骨骼", Default = aimbotBone, Options = {"Head","Neck","UpperTorso","HumanoidRootPart"}, Callback = function(v) aimbotBone = v end })
        
        
        -----------------------------------------------------------------
        -- 删除阴影（全局开关）
        -----------------------------------------------------------------
        Tab4:AddToggle({
            Name = "删除阴影",
            Default = false,
            Callback = function(v)
                if game.Lighting then
                    game.Lighting.GlobalShadows = not v
                end
                for _, l in ipairs(workspace:GetDescendants()) do
                    if l:IsA("BasePart") or l:IsA("MeshPart") then
                        l.CastShadow = not v
                    end
                end
                OrionLib:MakeNotification({Name = "提示", Content = v and "阴影已删除" or "阴影已恢复", Time = 2})
            end
        })

        -----------------------------------------------------------------
        -- 优化后的飞行功能 (修复bug并提高流畅度)
        -----------------------------------------------------------------
        local flying = false
        local flySpeed = 50
        local bg, bv
        local ctrl = {f = 0, b = 0, l = 0, r = 0, u = 0, d = 0}
        local flyConnection
        
        -- 更流畅的飞行循环
        local function flyLoop()
            while flying and task.wait() do
                local character = game.Players.LocalPlayer.Character
                if not character then break end
                
                local torso = character:FindFirstChild("HumanoidRootPart") or 
                              character:FindFirstChild("Torso") or 
                              character:FindFirstChild("UpperTorso")
                if not torso then break end
                
                -- 计算移动方向
                local moveDirection = Vector3.new(ctrl.r - ctrl.l, ctrl.u - ctrl.d, ctrl.b - ctrl.f)
                if moveDirection.Magnitude > 0 then
                    moveDirection = moveDirection.Unit
                end
                
                -- 应用飞行速度
                local camera = workspace.CurrentCamera
                local cameraCFrame = camera.CFrame
                local cameraLookVector = cameraCFrame.LookVector
                local cameraRightVector = cameraCFrame.RightVector
                local cameraUpVector = cameraCFrame.UpVector
                
                local velocity = (cameraLookVector * moveDirection.Z * flySpeed) +
                                (cameraRightVector * moveDirection.X * flySpeed) +
                                (cameraUpVector * moveDirection.Y * flySpeed)
                
                if bv then bv.Velocity = velocity end
            end
        end
        
        local function startFlying()
            if flying then return end
            
            local character = game.Players.LocalPlayer.Character
            if not character then 
                OrionLib:MakeNotification({
                    Name = "飞行错误",
                    Content = "找不到角色",
                    Time = 3
                })
                return 
            end
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid then 
                OrionLib:MakeNotification({
                    Name = "飞行错误",
                    Content = "找不到Humanoid",
                    Time = 3
                })
                return 
            end
            
            flying = true
            
            -- 创建飞行控制组件
            local torso = character:FindFirstChild("HumanoidRootPart") or 
                          character:Find极长的代码，无法全部显示，但关键修复已添加